/* eslint-disable */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  /** Represents untyped JSON */
  JSON: any;
};

export type AuthorizationResult = {
  __typename?: 'AuthorizationResult';
  /** Human-readable error message */
  message?: Maybe<Scalars['String']>;
  /** Reasons of check failure */
  reasons?: Maybe<FailureReasons>;
  /** Result of applying a policy rule */
  value: Scalars['Boolean'];
};

/** Autogenerated input type of CreateDeckMutation */
export type CreateDeckMutationInput = {
  /** An optional description for the deck */
  description?: Maybe<Scalars['String']>;
  /** The emoji for the new deck */
  emoji?: Maybe<Scalars['String']>;
  /** The alt text of the emoji */
  emojiAlt?: Maybe<Scalars['String']>;
  /** The name of the new deck */
  name: Scalars['String'];
  /** The visibility for the new deck */
  visibilityMode: DeckVisbilityMode;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateDeckMutation */
export type CreateDeckMutationPayload = {
  __typename?: 'CreateDeckMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pagination edge for the newly created deck */
  deckEdge?: Maybe<DeckEdge>;
  /** Whether the mutation ran successfully or not */
  success: Scalars['Boolean'];
  /** The validation errors returned from this mutation */
  validationErrors?: Maybe<ValidationError>;
};

/** A deck represents a collection of flashcards */
export type Deck = Node & {
  __typename?: 'Deck';
  canDestroy: AuthorizationResult;
  canUpdate: AuthorizationResult;
  canView: AuthorizationResult;
  /** The timestamp this node was created at */
  createdAt: Scalars['ISO8601DateTime'];
  /** An optional description of the deck */
  description?: Maybe<Scalars['String']>;
  /** An optional emoji for the deck */
  emoji?: Maybe<Scalars['String']>;
  /** The alt text for the deck emoji */
  emojiAlt?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The name of the deck */
  name: Scalars['String'];
  /** The timestamp this node was last updated at */
  updatedAt: Scalars['ISO8601DateTime'];
  /** The user whom the deck belongs to */
  user: User;
  /** The visiblity of the deck */
  visibilityMode?: Maybe<DeckVisbilityMode>;
};

/** The connection type for Deck. */
export type DeckConnection = {
  __typename?: 'DeckConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeckEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Deck>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DeckEdge = {
  __typename?: 'DeckEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Deck>;
};

/** Controls the visiblity of a user-create deck */
export enum DeckVisbilityMode {
  /** A public deck that is accessible by anyone, and can be found in searches */
  Public = 'PUBLIC',
  /** A private deck that is only visible to the current user */
  Private = 'PRIVATE',
  /** A deck that can only be accessed by a unique link */
  Unlisted = 'UNLISTED',
  /** A deck that can only be accessed by the owner, and people who they invite */
  InviteOnly = 'INVITE_ONLY'
}

export type FailureReasons = {
  __typename?: 'FailureReasons';
  /** JSON-encoded map of reasons */
  details: Scalars['String'];
  /** Human-readable errors */
  fullMessages: Array<Scalars['String']>;
};


/** Autogenerated input type of IdentityCheckMutation */
export type IdentityCheckMutationInput = {
  /** The value of the identity */
  identity: Scalars['String'];
  /** The type of identity to check for */
  identityType: IdentityType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of IdentityCheckMutation */
export type IdentityCheckMutationPayload = {
  __typename?: 'IdentityCheckMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether the identity was present or not */
  exists: Scalars['Boolean'];
};

/** A user's identity type */
export enum IdentityType {
  /** The user's email address */
  Email = 'EMAIL',
  /** The user's username */
  Username = 'USERNAME'
}


/** The root mutation type */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a new deck for the authenticated user and returns it */
  createDeck?: Maybe<CreateDeckMutationPayload>;
  /** Checks to see if an identity (.i.e. a user) exists with a given login */
  identityCheck?: Maybe<IdentityCheckMutationPayload>;
  /** Updates a deck with a given id */
  updateDeck?: Maybe<UpdateDeckMutationPayload>;
  /** Creates or returns new user account from their firebase id token */
  upsertUser?: Maybe<UpsertUserMutationPayload>;
};


/** The root mutation type */
export type MutationCreateDeckArgs = {
  input: CreateDeckMutationInput;
};


/** The root mutation type */
export type MutationIdentityCheckArgs = {
  input: IdentityCheckMutationInput;
};


/** The root mutation type */
export type MutationUpdateDeckArgs = {
  input: UpdateDeckMutationInput;
};


/** The root mutation type */
export type MutationUpsertUserArgs = {
  input: UpsertUserMutationInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** Root query field */
export type Query = {
  __typename?: 'Query';
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>;
  /** Returns the current authenticated user */
  viewer: User;
};


/** Root query field */
export type QueryNodeArgs = {
  id: Scalars['ID'];
};


/** Root query field */
export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};

/** Autogenerated input type of UpdateDeckMutation */
export type UpdateDeckMutationInput = {
  /** The id of the deck to update */
  deckId: Scalars['ID'];
  /** An updated description for the deck */
  description?: Maybe<Scalars['String']>;
  /** The updated emoji for the deck */
  emoji?: Maybe<Scalars['String']>;
  /** The updated alt text of the emoji */
  emojiAlt?: Maybe<Scalars['String']>;
  /** The updated name of the new deck */
  name?: Maybe<Scalars['String']>;
  /** The updated visibility for the deck */
  visibilityMode?: Maybe<DeckVisbilityMode>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateDeckMutation */
export type UpdateDeckMutationPayload = {
  __typename?: 'UpdateDeckMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated deck */
  deck?: Maybe<Deck>;
  /** Whether the mutation ran successfully or not */
  success: Scalars['Boolean'];
  /** The validation errors returned from this mutation */
  validationErrors?: Maybe<ValidationError>;
};

/** An upsert user mutation failure reason */
export enum UpsertUserFailureReason {
  /** The auth header was missing or invalid in the request */
  Unauthenticated = 'UNAUTHENTICATED',
  /** A validation error has occurred */
  ValidationError = 'VALIDATION_ERROR'
}

/** Autogenerated input type of UpsertUserMutation */
export type UpsertUserMutationInput = {
  /** The user's full name */
  name?: Maybe<Scalars['String']>;
  /** The user's unique username. Will be autogenerated if not given */
  username?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpsertUserMutation */
export type UpsertUserMutationPayload = {
  __typename?: 'UpsertUserMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The reason why the upsert request failed */
  failureReason?: Maybe<UpsertUserFailureReason>;
  /** The created user account */
  user?: Maybe<User>;
  /** Validation errors */
  validationErrors?: Maybe<ValidationError>;
};

/** A user object */
export type User = Node & {
  __typename?: 'User';
  /** The timestamp this node was created at */
  createdAt: Scalars['ISO8601DateTime'];
  /** A connection holding all of the user's decks */
  decks?: Maybe<DeckConnection>;
  /** The user's email address */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The timestamp this node was last updated at */
  updatedAt: Scalars['ISO8601DateTime'];
  /** The user's username */
  username: Scalars['String'];
};


/** A user object */
export type UserDecksArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A mutation validation error object */
export type ValidationError = {
  __typename?: 'ValidationError';
  /** Summary of the validation errors */
  description: Scalars['String'];
  /** A JSON-object that contains a detail of each of the field-level validation errors */
  details: Scalars['JSON'];
  /** Full error messages for each field */
  fullMessages: Array<Scalars['String']>;
  /** A json object that contains all the validation errors for a give field */
  messages: Scalars['JSON'];
};

export type MeFragment = (
  { __typename?: 'User' }
  & Pick<User, 'id'>
);

export type IdentityCheckMutationVariables = Exact<{
  identity: Scalars['String'];
  identityType?: Maybe<IdentityType>;
}>;


export type IdentityCheckMutation = (
  { __typename?: 'Mutation' }
  & { identityCheck?: Maybe<(
    { __typename?: 'IdentityCheckMutationPayload' }
    & Pick<IdentityCheckMutationPayload, 'exists'>
  )> }
);

export type UpsertUserMutationVariables = Exact<{
  name?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
}>;


export type UpsertUserMutation = (
  { __typename?: 'Mutation' }
  & { upsertUser?: Maybe<(
    { __typename?: 'UpsertUserMutationPayload' }
    & Pick<UpsertUserMutationPayload, 'failureReason'>
    & { user?: Maybe<(
      { __typename?: 'User' }
      & MeFragment
    )>, validationErrors?: Maybe<(
      { __typename?: 'ValidationError' }
      & Pick<ValidationError, 'messages' | 'details'>
    )> }
  )> }
);

export type ViewerQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerQuery = (
  { __typename?: 'Query' }
  & { viewer: (
    { __typename?: 'User' }
    & MeFragment
  ) }
);

export type DeckRow_DeckFragment = (
  { __typename?: 'Deck' }
  & Pick<Deck, 'id' | 'visibilityMode' | 'emoji' | 'emojiAlt' | 'description' | 'createdAt' | 'name'>
);

export type CreateDeckMutationVariables = Exact<{
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  emoji?: Maybe<Scalars['String']>;
  emojiAlt?: Maybe<Scalars['String']>;
  visibilityMode?: Maybe<DeckVisbilityMode>;
}>;


export type CreateDeckMutation = (
  { __typename?: 'Mutation' }
  & { createDeck?: Maybe<(
    { __typename?: 'CreateDeckMutationPayload' }
    & Pick<CreateDeckMutationPayload, 'success'>
    & { deckEdge?: Maybe<(
      { __typename?: 'DeckEdge' }
      & Pick<DeckEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename?: 'Deck' }
        & Pick<Deck, 'id' | 'visibilityMode'>
      )> }
    )>, validationErrors?: Maybe<(
      { __typename?: 'ValidationError' }
      & Pick<ValidationError, 'details' | 'messages'>
    )> }
  )> }
);

export type UpdateDeckMutationVariables = Exact<{
  deckId: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  emoji?: Maybe<Scalars['String']>;
  emojiAlt?: Maybe<Scalars['String']>;
  visibilityMode?: Maybe<DeckVisbilityMode>;
}>;


export type UpdateDeckMutation = (
  { __typename?: 'Mutation' }
  & { updateDeck?: Maybe<(
    { __typename?: 'UpdateDeckMutationPayload' }
    & Pick<UpdateDeckMutationPayload, 'success'>
    & { deck?: Maybe<(
      { __typename?: 'Deck' }
      & Pick<Deck, 'id' | 'visibilityMode'>
    )>, validationErrors?: Maybe<(
      { __typename?: 'ValidationError' }
      & Pick<ValidationError, 'details' | 'messages'>
    )> }
  )> }
);

export type ViewerDecksQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
}>;


export type ViewerDecksQuery = (
  { __typename?: 'Query' }
  & { viewer: (
    { __typename?: 'User' }
    & Pick<User, 'id'>
    & { decks?: Maybe<(
      { __typename?: 'DeckConnection' }
      & { edges?: Maybe<Array<Maybe<(
        { __typename?: 'DeckEdge' }
        & Pick<DeckEdge, 'cursor'>
        & { node?: Maybe<(
          { __typename?: 'Deck' }
          & Pick<Deck, 'id'>
          & DeckRow_DeckFragment
        )> }
      )>>>, pageInfo: (
        { __typename?: 'PageInfo' }
        & Pick<PageInfo, 'hasNextPage' | 'endCursor'>
      ) }
    )> }
  ) }
);

export const MeFragmentDoc = gql`
    fragment Me on User {
  id
}
    `;
export const DeckRow_DeckFragmentDoc = gql`
    fragment DeckRow_deck on Deck {
  id
  visibilityMode
  emoji
  emojiAlt
  description
  createdAt
  name
}
    `;
export const IdentityCheckDocument = gql`
    mutation IdentityCheck($identity: String!, $identityType: IdentityType = EMAIL) {
  identityCheck(input: {identity: $identity, identityType: $identityType}) {
    exists
  }
}
    `;
export type IdentityCheckMutationFn = Apollo.MutationFunction<IdentityCheckMutation, IdentityCheckMutationVariables>;

/**
 * __useIdentityCheckMutation__
 *
 * To run a mutation, you first call `useIdentityCheckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useIdentityCheckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [identityCheckMutation, { data, loading, error }] = useIdentityCheckMutation({
 *   variables: {
 *      identity: // value for 'identity'
 *      identityType: // value for 'identityType'
 *   },
 * });
 */
export function useIdentityCheckMutation(baseOptions?: Apollo.MutationHookOptions<IdentityCheckMutation, IdentityCheckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<IdentityCheckMutation, IdentityCheckMutationVariables>(IdentityCheckDocument, options);
      }
export type IdentityCheckMutationHookResult = ReturnType<typeof useIdentityCheckMutation>;
export type IdentityCheckMutationResult = Apollo.MutationResult<IdentityCheckMutation>;
export type IdentityCheckMutationOptions = Apollo.BaseMutationOptions<IdentityCheckMutation, IdentityCheckMutationVariables>;
export const UpsertUserDocument = gql`
    mutation UpsertUser($name: String, $username: String) {
  upsertUser(input: {name: $name, username: $username}) {
    user {
      ...Me
    }
    failureReason
    validationErrors {
      messages
      details
    }
  }
}
    ${MeFragmentDoc}`;
export type UpsertUserMutationFn = Apollo.MutationFunction<UpsertUserMutation, UpsertUserMutationVariables>;

/**
 * __useUpsertUserMutation__
 *
 * To run a mutation, you first call `useUpsertUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertUserMutation, { data, loading, error }] = useUpsertUserMutation({
 *   variables: {
 *      name: // value for 'name'
 *      username: // value for 'username'
 *   },
 * });
 */
export function useUpsertUserMutation(baseOptions?: Apollo.MutationHookOptions<UpsertUserMutation, UpsertUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertUserMutation, UpsertUserMutationVariables>(UpsertUserDocument, options);
      }
export type UpsertUserMutationHookResult = ReturnType<typeof useUpsertUserMutation>;
export type UpsertUserMutationResult = Apollo.MutationResult<UpsertUserMutation>;
export type UpsertUserMutationOptions = Apollo.BaseMutationOptions<UpsertUserMutation, UpsertUserMutationVariables>;
export const ViewerDocument = gql`
    query Viewer {
  viewer {
    ...Me
  }
}
    ${MeFragmentDoc}`;

/**
 * __useViewerQuery__
 *
 * To run a query within a React component, call `useViewerQuery` and pass it any options that fit your needs.
 * When your component renders, `useViewerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useViewerQuery({
 *   variables: {
 *   },
 * });
 */
export function useViewerQuery(baseOptions?: Apollo.QueryHookOptions<ViewerQuery, ViewerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ViewerQuery, ViewerQueryVariables>(ViewerDocument, options);
      }
export function useViewerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ViewerQuery, ViewerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ViewerQuery, ViewerQueryVariables>(ViewerDocument, options);
        }
export type ViewerQueryHookResult = ReturnType<typeof useViewerQuery>;
export type ViewerLazyQueryHookResult = ReturnType<typeof useViewerLazyQuery>;
export type ViewerQueryResult = Apollo.QueryResult<ViewerQuery, ViewerQueryVariables>;
export const CreateDeckDocument = gql`
    mutation CreateDeck($name: String!, $description: String, $emoji: String, $emojiAlt: String, $visibilityMode: DeckVisbilityMode = PRIVATE) {
  createDeck(
    input: {name: $name, emoji: $emoji, emojiAlt: $emojiAlt, description: $description, visibilityMode: $visibilityMode}
  ) {
    deckEdge {
      cursor
      node {
        id
        visibilityMode
      }
    }
    validationErrors {
      details
      messages
    }
    success
  }
}
    `;
export type CreateDeckMutationFn = Apollo.MutationFunction<CreateDeckMutation, CreateDeckMutationVariables>;

/**
 * __useCreateDeckMutation__
 *
 * To run a mutation, you first call `useCreateDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeckMutation, { data, loading, error }] = useCreateDeckMutation({
 *   variables: {
 *      name: // value for 'name'
 *      description: // value for 'description'
 *      emoji: // value for 'emoji'
 *      emojiAlt: // value for 'emojiAlt'
 *      visibilityMode: // value for 'visibilityMode'
 *   },
 * });
 */
export function useCreateDeckMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeckMutation, CreateDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDeckMutation, CreateDeckMutationVariables>(CreateDeckDocument, options);
      }
export type CreateDeckMutationHookResult = ReturnType<typeof useCreateDeckMutation>;
export type CreateDeckMutationResult = Apollo.MutationResult<CreateDeckMutation>;
export type CreateDeckMutationOptions = Apollo.BaseMutationOptions<CreateDeckMutation, CreateDeckMutationVariables>;
export const UpdateDeckDocument = gql`
    mutation UpdateDeck($deckId: ID!, $name: String, $description: String, $emoji: String, $emojiAlt: String, $visibilityMode: DeckVisbilityMode = PRIVATE) {
  updateDeck(
    input: {deckId: $deckId, name: $name, emoji: $emoji, emojiAlt: $emojiAlt, description: $description, visibilityMode: $visibilityMode}
  ) {
    deck {
      id
      visibilityMode
    }
    validationErrors {
      details
      messages
    }
    success
  }
}
    `;
export type UpdateDeckMutationFn = Apollo.MutationFunction<UpdateDeckMutation, UpdateDeckMutationVariables>;

/**
 * __useUpdateDeckMutation__
 *
 * To run a mutation, you first call `useUpdateDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDeckMutation, { data, loading, error }] = useUpdateDeckMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *      name: // value for 'name'
 *      description: // value for 'description'
 *      emoji: // value for 'emoji'
 *      emojiAlt: // value for 'emojiAlt'
 *      visibilityMode: // value for 'visibilityMode'
 *   },
 * });
 */
export function useUpdateDeckMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDeckMutation, UpdateDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDeckMutation, UpdateDeckMutationVariables>(UpdateDeckDocument, options);
      }
export type UpdateDeckMutationHookResult = ReturnType<typeof useUpdateDeckMutation>;
export type UpdateDeckMutationResult = Apollo.MutationResult<UpdateDeckMutation>;
export type UpdateDeckMutationOptions = Apollo.BaseMutationOptions<UpdateDeckMutation, UpdateDeckMutationVariables>;
export const ViewerDecksDocument = gql`
    query ViewerDecks($first: Int = 15, $after: String) {
  viewer {
    id
    decks(first: $first, after: $after) {
      edges {
        cursor
        node {
          id
          ...DeckRow_deck
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
}
    ${DeckRow_DeckFragmentDoc}`;

/**
 * __useViewerDecksQuery__
 *
 * To run a query within a React component, call `useViewerDecksQuery` and pass it any options that fit your needs.
 * When your component renders, `useViewerDecksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useViewerDecksQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useViewerDecksQuery(baseOptions?: Apollo.QueryHookOptions<ViewerDecksQuery, ViewerDecksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ViewerDecksQuery, ViewerDecksQueryVariables>(ViewerDecksDocument, options);
      }
export function useViewerDecksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ViewerDecksQuery, ViewerDecksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ViewerDecksQuery, ViewerDecksQueryVariables>(ViewerDecksDocument, options);
        }
export type ViewerDecksQueryHookResult = ReturnType<typeof useViewerDecksQuery>;
export type ViewerDecksLazyQueryHookResult = ReturnType<typeof useViewerDecksLazyQuery>;
export type ViewerDecksQueryResult = Apollo.QueryResult<ViewerDecksQuery, ViewerDecksQueryVariables>;